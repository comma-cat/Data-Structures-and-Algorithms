# 建图
## 图的分类
1. 有向图  无向图
2. 带权图 不带全图
这里无向图实际上代表的是“双向”图，箭头是双向的
## 建图方法
### 邻接矩阵法
![[Pasted image 20250921155641.png]]邻接矩阵实质上是一个二维静态数组，如果i指向j，那么就在[i,j]位置值设为1，其他位置全为初始值0，以此来标记i->j存在联系
![[Pasted image 20250921155831.png]]如果该图是带权图，那么就将标为”1“的位置替换为该边的权重即可，通过这个方法，我们就可以由图写出对应的邻接矩阵，也能由邻接矩阵确定该图的指向情况
（这里是为了下标对应，对于下标为0的空间，申请而不使用）
代码实现部分：（有向带权）
```
void build(int n) {
    // 邻接矩阵清空
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            graph1[i][j] = 0; // 0表示没有边
        }
    } //在使用前必须二维静态数组手动初始化为0
void directGraph(vector<vector<int>>& edges) {
    // 邻接矩阵建图：graph1[起点][终点] = 权重
    for (auto& edge : edges) {
        graph1[edge[0]][edge[1]] = edge[2]; //edge[0]为起点，edge[1]为终点，edge[2]为权重
   // 如果无向则还需添加 graph1[edge[1]][edge[0]] = edge[2];
    }   /*edges是一个二维数组,这里相当于对edge这个二维数组进行行的遍历，对于
          edge[i][j]来说这里的edge相当于edge[i],edge[0]相当于edge[i][0]
        */
    //如果没有权重，那么将权重部分换为1即可
```
对于无向图，给出一对[i,j]，在赋值的时候就需要赋值两次，最后得出的矩阵必然是对称的
### 邻接表法
邻接表法实际上是一个二维动态数组，第一层表示图中的点，第二层表示该点指向的点以及权重，
对于不带权图，第二层只需存储点，是一个一个的数据，因此二维动态数组是vector<vector< int >>类型。而对于带权图，第二层不仅要存储点，也要存储改指向该点的边的权重，因此存储的是一个数据对，在c++中可以用pair类型,vector<vector<pair<int, int>>>(也可以用二维静态数组)
代码实现部分（以带权图为例）
```
vector<vector<pair<int,int>>> graph;
//初始化需要清空和准备
graph.clear();
for(int i = 0 ;i<=n;i++)  //0申而不用
{
   graph.push_back(vector<pair<int, int>>());
   //让graph的每一行都是一个pair型的动态数组，并且初值为0
}
for(auto &edge : edges)
{
  graph[edge[0]].push_back({edge[1],edge[2]});
  //     起点                 终点     权重
  /*同样地，edges是一个二维数组,这里相当于对edge这个二维数组进行“行”的遍历，对于
          edge[i][j]来说这里的edge相当于edge[i],edge[0]相当于edge[i][0]
   */
  //无向则需添加 graph[edge[1]].push_back({edge[0], edge[2]});
}
```
### 链式前向星法
一般而言邻接表法使用最多，但邻接表法是动态的，而链式前向星法是静态的
以下是对比：
![[Pasted image 20250921163750.png]]链式前向星法的实质是，利用静态的数组来模拟链表，每次加入边就相当于头插法
核心逻辑：
- head存储的是该节点的“第一条边”；
- next存储的是每条边的下一条边；
- to表示访问到的节点，weight表示该边的权重；
核心逻辑是前两点：
```note
  每当我们接受到第cnt条边[i,j]的有向连接时，我们首先查看head[i]，来了解i节点的第一条边是什么，由于[i,j]已经建立，因此第一条边head[i]要替换为i->j这条边，因此我们先将next[ cnt ] = head[i]（将新边的下一条边设为当前i的第一条边）,并且得到访问的节点to[cnt]以及权重weight[cnt]，然后更新i的第一条边head[i] = cnt;然后将cnt++，表示开始加入下一条边

```
接下来附上三种方法的代码实现：
```
#include <iostream>
#include <vector>
#include <cstring>
#include <algorithm>
using namespace std;

// 点的最大数量
const int MAXN = 11;

// 边的最大数量
// 只有链式前向星方式建图需要这个数量
// 注意：如果无向图的最大数量是m条边，需要准备m*2的空间
// 因为一条无向边要加两条有向边
const int MAXM = 21;

// 邻接矩阵方式建图
// graph1[i][j] 表示从点i到点j的边权重，0表示没有边
int graph1[MAXN][MAXN];

// 邻接表方式建图
// 使用vector<vector<pair<int, int>>>，每个点对应一个列表
// 每个列表存储pair<邻居节点, 边权重>
vector<vector<pair<int, int>>> graph2;

// 链式前向星方式建图
int head[MAXN];    // head[i] 存储点i的第一条边的索引
int next_[MAXM];   // next_[ei] 存储下一条边的索引
int to[MAXM];      // to[ei] 存储边ei指向的节点
int weight[MAXM];  // weight[ei] 存储边ei的权重
int cnt;           // 边的计数器，从1开始

// 初始化图结构
void build(int n) {
    // 邻接矩阵清空
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            graph1[i][j] = 0; // 0表示没有边
        }
    }

    // 邻接表清空和准备
    graph2.clear();
    // 下标需要支持1~n，所以加入n+1个列表，0下标准备但不用
    for (int i = 0; i <= n; i++) {
        graph2.push_back(vector<pair<int, int>>());
    }

    // 链式前向星清空
    cnt = 1; // 边的索引从1开始
    memset(head + 1, 0, n * sizeof(int)); // 初始化head数组为0
}

// 链式前向星加边
void addEdge(int u, int v, int w) {
    // u -> v , 边权重是w
    next_[cnt] = head[u];  // 新边的next指向u原来的第一条边
    to[cnt] = v;           // 新边指向v
    weight[cnt] = w;       // 设置边权重
    head[u] = cnt++;       // u的head指向新边，计数器增加
}

// 三种方式建立有向图带权图
void directGraph(vector<vector<int>>& edges) {
    // 邻接矩阵建图：graph1[起点][终点] = 权重
    for (auto& edge : edges) {
        graph1[edge[0]][edge[1]] = edge[2];
    }

    // 邻接表建图：每个点存储其出边(目标节点, 权重)
    for (auto& edge : edges) {
        graph2[edge[0]].push_back({ edge[1], edge[2] });
    }

    // 链式前向星建图
    for (auto& edge : edges) {
        addEdge(edge[0], edge[1], edge[2]);
    }
}

// 三种方式建立无向图带权图
void undirectGraph(vector<vector<int>>& edges) {
    // 邻接矩阵建图：无向图需要对称设置
    for (auto& edge : edges) {
        graph1[edge[0]][edge[1]] = edge[2];
        graph1[edge[1]][edge[0]] = edge[2];
    }

    // 邻接表建图：无向图需要双向添加
    for (auto& edge : edges) {
        graph2[edge[0]].push_back({ edge[1], edge[2] });
        graph2[edge[1]].push_back({ edge[0], edge[2] });
    }

    // 链式前向星建图：无向图需要添加两条反向边
    for (auto& edge : edges) {
        addEdge(edge[0], edge[1], edge[2]);
        addEdge(edge[1], edge[0], edge[2]);
    }
}

// 遍历并打印三种图的表示方式
void traversal(int n) {
    cout << "邻接矩阵遍历 :" << endl;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cout << graph1[i][j] << " ";
        }
        cout << endl;
    }

    cout << "邻接表遍历 :" << endl;
    for (int i = 1; i <= n; i++) {
        cout << i << "(邻居、边权) : ";
        for (auto& edge : graph2[i]) {
            cout << "(" << edge.first << "," << edge.second << ") ";
        }
        cout << endl;
    }

    cout << "链式前向星 :" << endl;
    for (int i = 1; i <= n; i++) {
        cout << i << "(邻居、边权) : ";
        // 链式前向星的遍历方式：从head[i]开始，沿着next指针遍历
        for (int ei = head[i]; ei > 0; ei = next_[ei]) {
            cout << "(" << to[ei] << "," << weight[ei] << ") ";
        }
        cout << endl;
    }
}

int main() {
    // 理解了带权图的建立过程，也就理解了不带权图
    // 点的编号为1...n

    // 例子1：有向带权图
    cout << "有向带权图示例：" << endl;
    int n1 = 4;
    vector<vector<int>> edges1 = { {1, 3, 6}, {4, 3, 4}, {2, 4, 2}, {1, 2, 7}, {2, 3, 5}, {3, 1, 1} };
    build(n1);
    directGraph(edges1);
    traversal(n1);

    cout << "==============================" << endl;

    // 例子2：无向带权图
    cout << "无向带权图示例：" << endl;
    int n2 = 5;
    vector<vector<int>> edges2 = { {3, 5, 4}, {4, 1, 1}, {3, 4, 2}, {5, 2, 4}, {2, 3, 7}, {1, 5, 5}, {4, 2, 6} };
    build(n2);
    undirectGraph(edges2);
    traversal(n2);

    return 0;
}
```
注意遍历方式：
```
for (int i = 1; i <= n; i++) {
        cout << i << "(邻居、边权) : ";
        // 链式前向星的遍历方式：从head[i]开始，沿着next指针遍历
        for (int ei = head[i]; ei > 0; ei = next_[ei]) {
            cout << "(" << to[ei] << "," << weight[ei] << ") ";
        }
        cout << endl;
    }
```
