# 堆的概念与性质
堆是一种基于完全二叉树的特殊数据结构，用于快速访问最大值或最小值，堆的数据结构特性包含以下几点：
- 堆是一种完全二叉树，除了最后一层都是满的
- 大根堆是父节点大于两个子节点，小根堆是父节点小于两个子节点
- 堆通常是以数组和priority_queue优先队列为容器的
性质：
- 当前为第i个节点，则父节点为：(i-1)/2;
- 当前为第i个节点,则其左右子节点分别为：2i+1,2i+2
- 大根堆的根就是最大值，小根堆的根就是最小值

# 建堆（以建大根堆为例）
## 从上往下建堆---heapInsert
### 过程：
每插入一个数据，都将这个数据与父节点进行比较，如果大于父节点，则交换这两个节点，并在父节点处再次递归
```
void swap(int arr[], int p1, int p2)
{
	int temp = arr[p1];
	arr[p1] = arr[p2];
	arr[p2] = temp;
}
void heapInsert(int arr[], int position)
{
	int parent = (position - 1) / 2;//父亲节点
	while (position>0&&arr[position] > arr[parent])
	{  
		swap(arr, position, parent);
		position = parent;
		parent = (position - 1) / 2;
	}//parent为父，position为当前
	return;
}
```
由于每一次heapInsert，最多都可能递归 **二叉树的高度** 次，如果有n个数据，那么二叉树高度为logn级别，那么整个建堆过程时间复杂度就是o(n * logn)的
## 从下往上建堆---heapify
过程：
给出一个数据，该数据位于i位置，将该节点与其左右节点进行比较，如果父节点比左右节点中的较大者小，则交换父节点与子节点中较大者，并从子节点中较大者继续递归
```
void heapify(int arr[], int position, int size)
{
	int index = 2 * position + 1;//index为子节点位置
	while (index < size)//要进行heapify，必须保证子节点在范围内
	{
		int bigger = index + 1 < size && arr[index + 1] > arr[index] ? index + 1 : index;
		//bigger为较大孩子的index
		if(arr[position] < arr[bigger])
		{
			swap(arr, position, bigger);
			position = bigger;
			index = 2 * position + 1;
		}//如果父比子小，则交换，并且更新新的position和index
		else
		{
			return;
		}//否则返回空直接结束
	}
}
```
对于一个完全二叉树而言，层数越深，节点越多，但是heapify的优势在于：
在节点多的层递归的次数少，在节点少的层递归的次数多，而heapInsert是层数越多，高度越高，从而递归的层数也更多，这就是heapify相较于heapInsert的优势
假如有n个数据，高度为logn级别，那么heapify需要进行操作的次数：
1* logn + 2 * log(n/2) + 4  * log(n/4) + ........ ->o(n)
注：log(n/2)代表logn-1
即：使用heapify建堆，时间复杂度为o(n)
# 堆的应用
## 堆排序（以大根堆为例）
过程：
已知n个元素形成的大根堆中，堆顶是最大值，进行堆排序，只需要将堆顶元素与堆的最后一个元素交换（此时最后一个元素即为堆的最大值），让size-1，然后再从堆顶进行一次heapify（此时前n-1个元素又形成了堆），再次重复上述操作，每一次交换，新的最大值就移到右侧，最终就形成了一个升序的排列
```
while(size>1)//size为1时，堆中只有一个元素，不必再排
{
	swap(arr, 0, --size);
	heapify(arr,0,size);
}
```
注意到，每取一个最大值之前，首先要进行一次heapify，那么n个元素，就要进行n-1次heapify，而每次heapify都是从堆顶进行的，高度为logn，那么时间复杂度即为O(n * logn);
而堆排序整个过程都是在原数组进行的，不需要额外空间，因此空间复杂度为O(1);
### heapInsert-插入一个元素并自上而下调整堆(先上递归)
### heapify-自下而上调整堆（向下递归）
## 优先级队列priority_queue
优先级队列并不是普通队列先进先出，而是：**优先级高的先出，优先级低的后出**
priority_queue的语法规则
priority_queue<存储的元素类型，存储的容器，比较器>
c++中默认是大根堆，如果要定义小根堆则比较器处用greater< int >
关于比较器：比较器是一个类或结构体，注意：值为true，表示下一个元素需要”顶上来“，说明第一个元素优先级低，第二个元素优先级高，值为false，则表示第一个元素优先级高，第二个元素优先级低


关于priority_queue的补充

---
 C++ STL 堆操作函数总结

| 函数名                             | 功能                             | 内部原理（相当于）                                | 典型用法                                                                 | 时间复杂度         | 注意事项                                           |
| :------------------------------ | :----------------------------- | :--------------------------------------- | :------------------------------------------------------------------- | :------------ | :--------------------------------------------- |
| **`make_heap(begin, end)`**     | 将一段无序区间原地建成一个最大堆（默认 `less<T>`） | $\approx$ 一次性对整个数组执行 **heapify**（自底向上建堆） | `make_heap(v.begin(), v.end());`                                     | $O(n)$        | 若传入 `greater<T>`，则是最小堆。                        |
| **`push_heap(begin, end)`**     | 将新插入末尾的元素调整到正确堆位置              | $\approx$ **heapInsert**（自底向上上浮）         | `v.push_back(x);`<br>`push_heap(v.begin(), v.end());`                | $O(\log n)$   | 仅对**末尾元素**进行调整。在调用前，`[begin, end - 1)` 必须已经是堆。 |
| **`pop_heap(begin, end)`**      | 将堆顶与末尾元素交换，并重新调整前 $n-1$ 个元素为堆  | $\approx$ 交换堆顶 + **heapify**（自顶向下下沉）     | `pop_heap(v.begin(), v.end());`<br>`v.pop_back();`                   | $O(\log n)$   | **不会删除**元素，只是将其交换到末尾。移除元素需要额外的 `v.pop_back()`。 |
| **`sort_heap(begin, end)`**     | 利用堆排序将整个区间排序                   | $\approx$ 重复执行 `pop_heap`                | `make_heap(v.begin(), v.end());`<br>`sort_heap(v.begin(), v.end());` | $O(n \log n)$ | 结果是**升序**（若使用默认最大堆）。                           |
| **`is_heap(begin, end)`**       | 判断当前区间是否是堆结构                   | —                                        | `is_heap(v.begin(), v.end());`                                       | $O(n)$        | 常用于调试或验证。                                      |
| **`is_heap_until(begin, end)`** | 返回从 `begin` 起保持堆结构的最大前缀迭代器     | —                                        | —                                                                    | $O(n)$        | 找出堆性质被破坏的位置。                                   |
