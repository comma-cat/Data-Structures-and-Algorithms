# 基本结构
栈的逻辑可以理解成一个存放数据的容器，下端封口，上端不封口，就像一个敞口的瓶子，因此所有数据遵循”先进后出“的原则，因为越先进的数据越在瓶子的下面
# 栈的实现
## 用数组实现栈
```
#include<iostream>
using namespace std;
#define MAXSIZE 1000

int A[MAXSIZE];
int top = -1;  // 直接初始化

void push(int x)
{
    if (top >= MAXSIZE - 1)  // 修正边界检查
    {
        cout << "栈已满" << endl;
        return;
    }
    top++;
    A[top] = x;
}

void pop()
{
    if (top == -1)
    {
        cout << "栈为空" << endl;
        return;
    }
    top--;
}

bool Isempty()
{
    return (top == -1);
}

void Print()
{
    for (int i = 0; i <= top; i++)
    {
        cout << A[i] << " ";
    }
    cout << endl;
}

int Top()
{
    if (top == -1)
    {
        cout << "栈为空" << endl;
        return -1;
    }
    return A[top];
}

int main()
{
    push(2);
    push(3);
    Print();        // 输出: 2 3
    push(4);
    push(5);
    pop();
    Print();        // 输出: 2 3 4
    cout << "栈顶元素: " << Top() << endl; // 输出: 栈顶元素: 4
    
    return 0;
}
```
核心思想：存放元素就是让top指针右移并在数组相应位置写入数据
          弹出元素就是让top指针左移
          返回元素就是返回top所指向元素
## 用链表实现栈
```
#include<iostream>
using namespace std;

struct node
{
    int data;
    struct node* link;
};

struct node* top = NULL;  // 直接初始化

void push(int x)
{
    struct node* temp = new node();
    temp->data = x;
    temp->link = top;
    top = temp;
}

void pop()
{
    if (top == NULL)
    {
        cout << "栈为空" << endl;
        return;
    }
    struct node* temp = top;
    top = top->link;
    delete temp;
}

int Top()
{
    if (top == NULL)
    {
        cout << "栈为空" << endl;
        return -1;
    }
    return top->data;
}

bool IsEmpty()
{
    return (top == NULL);
}

void Print()
{
    if (top == NULL)
    {
        cout << "栈为空" << endl;
        return;
    }
    
    struct node* temp = top;
    cout << "栈顶 → ";
    while (temp != NULL)
    {
        cout << temp->data;
        if (temp->link != NULL) cout << " → ";
        temp = temp->link;
    }
    cout << " → 栈底" << endl;
}

int main()
{
    push(2);
    push(3);
    push(4);
    Print();  // 栈顶 → 4 → 3 → 2 → 栈底
    
    pop();
    Print();  // 栈顶 → 3 → 2 → 栈底
    
    cout << "栈顶元素: " << Top() << endl;  // 栈顶元素: 3
    
    return 0;
}
```
核心逻辑：存入元素就是在链表的头部插入节点
          弹出元素就是在链表的头部删除节点
          返回元素就是返回链表的头部所存放的数据
# 栈的运用
## 用栈实现字符串反转
```
#include <iostream>
#include <stack>
#include <string>
using namespace std;

void Reverse(char* c, size_t n)  // 使用 size_t 而不是 int
{
    if (n == 0) return;  // 处理空字符串

    stack<char> S;
    for (size_t i = 0; i < n; i++)
    {
        S.push(c[i]);
    }  //字符串元素入栈
    for (size_t i = 0; i < n; i++)
    {
        c[i] = S.top();
        S.pop();
    } //出栈的元素依次赋值给字符串
}

int main()
{
    string s;
    getline(cin, s);  // 使用 getline 而不是 cin >> 以支持空格
    cout << "Original: " << s << endl;

    if (!s.empty()) {
        Reverse(&s[0], s.size());
    }

    cout << "Reversed: " << s << endl;
    return 0;
}
```
核心逻辑：字符串进栈再出栈，出栈时的顺序恰好是逆序的，因此先进栈储存，再出栈赋值，即可完成字符串的反转
## 用栈实现链表反转
```
#include<iostream>
#include<stack>
using namespace std;

struct node
{
    int data;
    node* next;
};

void Insert(node** head, int x) //这里传入的是一个指针的指针
{
    node* temp = new node();
    temp->data = x;
    temp->next = *head;
    *head = temp;
}

void Print(node* head)
{
    node* temp = head;
    cout << "头部" << "→";
    while (temp != NULL)
    {
        cout << temp->data << "→";
        temp = temp->next;
    }
    cout << "尾部";
    cout << endl;
}

void Reverse(node** head)
{
    if (*head == NULL || (*head)->next == NULL) return;
    // 链表中只有0个或者1个节点，直接返回

    stack<node*> s;
    node* temp = *head;

    // 将所有节点压入栈中
    while (temp != NULL)
    {
        s.push(temp);
        temp = temp->next;
    }

    // 设置新的头节点
    *head = s.top();
    temp = *head;
    s.pop();

    // 重新连接节点
    while (!s.empty())
    {
        temp->next = s.top();
        temp = temp->next;
        s.pop();
    }
    temp->next = NULL;
}

void DeleteList(node** head)
{
    node* current = *head;
    node* next = NULL;

    while (current != NULL)
    {
        next = current->next;
        delete current;
        current = next;
    }
    *head = NULL;
} // 删除链表，释放内存

int main()
{
    node* head = NULL;

    Insert(&head, 2);
    Insert(&head, 3);
    Insert(&head, 4);
    Insert(&head, 5);

    cout << "原链表: ";
    Print(head);

    Reverse(&head);
    cout << "反转后: ";
    Print(head);

    // 释放内存
    DeleteList(&head);

    return 0;
}
```
核心逻辑：将各个节点的地址存入栈中，这样当取出栈的时候就是逆序
          因此在将head置于尾部后，从尾部开始，令节点的next指向栈顶元素，就可以实现反转链表
## 用栈检验括号匹配
```
#include <iostream>
#include <stack>
#include <string>
using namespace std;

int main()
{
    string str;
    cout << "请输入括号字符串: ";
    getline(cin, str);  // 使用getline可以读取包含空格的字符串

    stack<char> s;

    for (char c : str)
    {
        if (c == '(' || c == '[' || c == '{')
        {
            s.push(c);
        }
        else if (c == ')' || c == ']' || c == '}')
        {
            if (s.empty())
            {
                cout << "括号不匹配（右括号多余）" << endl;
                return 0;
            }

            char top = s.top();
            // 检查括号是否匹配
            if ((top == '(' && c == ')') ||
                (top == '[' && c == ']') ||
                (top == '{' && c == '}'))
            {
                s.pop();  // 匹配成功，弹出左括号
            }
            else
            {
                cout << "括号不匹配（类型不匹配）" << endl;
                return 0;
            }
        }
        // 可以忽略其他字符，只处理括号
    }

    if (s.empty())
    {
        cout << "括号匹配" << endl;
    }
    else
    {
        cout << "括号不匹配（左括号多余）" << endl;
    }

    return 0;
}
```
核心逻辑：如果出现左括号，存入栈中
          如果出现右括号，并且栈为空，说明不匹配
          如果出现右括号，并且与栈顶括号不对应，说明不匹配
          如果出现右括号，并且与栈顶括号匹配，那么将栈顶括号弹出，这一对括号已经匹配完成，继续向后遍历