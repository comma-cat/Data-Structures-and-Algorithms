# 基本概念
本质上是一个节点最多可以链接两个节点，从而形成树状结构，而根节点和链表中的head指针一样，是该数据结构的标识，要想访问二叉树就得通过根节点 root
## 二叉搜索树
二叉搜索树要求左节点的值小于根节点小于右节点，以及左子树的所有值小于根节点小于右子树的所有值
## 二叉平衡树
要求任意节点左右子树的高度差不超过 
## 高度与深度
高度： 从当前节点到最远的叶子节点的边数，叶子节点高度为0，空节点高度为-1
深度： 从根节点到当前节点的边数
整棵树的高度就是根节点的高度
## 二叉树高度与节点数的关系

- **最坏情况（退化为链表）**：  
    高度 = n − 1 （所有节点一条线）。
    
- **最好情况（完全二叉树 / 满二叉树）**：  
    高度大约是 **log₂n**。
    
    - 满二叉树：结点数 n = 2^(h+1) − 1  
        ⇒ 高度 h ≈ log₂(n+1) − 1
        
    - 完全二叉树：高度差不多也是 ⌊log₂n⌋。
        

所以： log2​(n+1)−1≤h≤n−1
# 基本操作
## 插入
```
node* Getnode(int x)
{
	struct node* temp = new node();
	temp->data = x;
	temp->left = NULL;
	temp->right = NULL;
	return temp;
}
void Insert(node** root, int x)
{
	if (*root == NULL)
	{
		*root = Getnode(x);
	}
	else if (x <= (*root)->data)
	{
		Insert(&(*root)->left, x);
	}
	else
	{
		Insert(&(*root)->right, x);
	}
	return;
}
```
## 搜索
```
bool Search(node* root, int x)  // 改为传值，更简洁
{
	if (root == NULL)
	{
		return false;
	}
	else if (root->data == x)
	{
		return true;
	}
	else if (root->data < x)
	{
		return Search(root->right, x);
	}
	else
	{
		return Search(root->left, x);
	}
}
```
## 找最值
```
node* FindMin(node* root)
{
	if (root == NULL)
	{
		return root;
	}
	struct node* current = root;
	while (current->left != NULL)
	{
		current = current->left;
	}
     return current;
}
node* FindMax(node* root)
{
	if (root == NULL)
	{
		return root;
	}
	struct node* current = root;
	while (current->right != NULL)
	{
		current = current->right;
	}
	return current;
}
```
## 求高度
```
int Height(node* root)
{
	if (root == NULL)
	{
		return -1;
	}
	else
		return max(Height(root->left), Height(root->right)) + 1;
}
```
## 层级遍历
```
void LevelOrder(node* root)
{
	if (root == NULL)
	{
		return;
	}
	queue<node*> Q;
	Q.push(root);

	while (!Q.empty())
	{
		struct node* current = Q.front();
		if (current->left != NULL)
		{
			Q.push(current->left);
		}
		if (current->right != NULL)
		{
			Q.push(current->right);
		}
		cout << current->data << " ";
		Q.pop();
	}

}
```
## 前序遍历
```
void PreOrder(node* root)
{
	if (root == NULL)
	{
		return;
	}
	cout << root->data << " ";
	PreOrder(root->left);
	PreOrder(root->right);
}
```
## 中序遍历
```
void InOrder(node* root)
{
	if (root == NULL)
	{
		return;
	}
	InOrder(root->left);
	cout << root->data << " ";
	InOrder(root->right);
}
```
## 后序遍历
```
void PostOrder(node* root)
{
	if (root == NULL)
	{
		return;
	}
	PostOrder(root->left);
	PostOrder(root->right);
	cout << root->data << " ";
}
```
## 删除节点
```
node* deletenode(node* root, int x)
{
	if (root == NULL)
		return root;
	else if (x < root->data)
	{
		root->left = deletenode(root->left, x);
	}
	else if (x > root->data)
	{
		root->right = deletenode(root->right, x);
	}
	else
	{

		if (root->left == NULL && root->right == NULL)
		{
			delete root;
			root = NULL;
		}
		else if (root->left == NULL)
		{
			struct node* temp = root;
			root = root->right;
			delete temp;
		}
		else if (root->right == NULL)
		{
			struct node* temp = root;
			root = root->left;
			delete temp;
		}
		else
		{
			struct node* temp = FindMin(root->right);
			root->data = temp->data;
			root->right = deletenode(root->right, root->data);
		}
	}
	return root;
}
```
## 寻找中序后继节点
```
node* Getsuccessor(node* root, int data)
{
	struct node* current = Find(root, data);
	if (current == NULL)
		return NULL;
	struct node* ancestor = root;
	if (current->right != NULL)
	{
		return FindMin(current->right);
	}
	else
	{
		struct node* successor = NULL;
		while (ancestor && current != ancestor)
		{
			if (data < ancestor->data)
			{
				successor = ancestor;
				ancestor = ancestor->left;
			}
			else
			{
				ancestor = ancestor->right;
			}
		}
		return successor;
	}

}
```
# 非递归方式二叉树的遍历
## 前序遍历
```
void preOrder(node* root)
{
	stack<node*> st;
	st.push(root);
	while (!st.empty())
	{
		node* temp = st.top();//这里相当于取“当前树”（除了第一次都为子树）的根
		st.pop();
		cout << temp->data << " ";
		if (temp->right) st.push(temp->right);
		if (temp->left) st.push(temp->left);
		//由于前序遍历顺序是根左右，因此放入栈就要先放右再放左
	}
	cout << endl;
}//前序遍历：根左右
```
核心思想：利用栈来模拟递归过程
## 中序遍历
```
void inOrder(node* root)
{
	node* cur = root;
	stack<node*> st;
	while (!st.empty() || cur)
	{
		while (cur)
		{
			st.push(cur);
			cur = cur->left;
		}
		cur = st.top();
		st.pop();
		cout << cur->data << " ";
		cur = cur->right;
	}
	cout << endl;
}//中序遍历：左根右
```
核心思想：先去往整棵树的最左端，并且将路上经过的点放入栈中，打印弹出之后（左处理完），就回到栈顶打印（根处理完），再来到右子树，并且将该右子树的根当作一棵新的树根来处理（右处理完），处理完之后再回到新的栈顶（“更大的”左处理完）

## 后序遍历（双栈实现）
```
void postOrder(node* root)
{
	stack<node*> st;//原栈
	stack<node*> collect;//收集栈
	st.push(root);
	while (!st.empty())
	{
		node* temp = st.top();
		st.pop();
		collect.push(temp);
		//不打印，而是放入收集栈中
		if (temp->left) st.push(temp->left);
		if (temp->right) st.push(temp->right);
		//先放左再放右，得到根右左的序列

	}
	while (!collect.empty())
	{
		node* temp = collect.top();
		collect.pop();
		cout << temp->data << " ";
	}
	//将收集栈遍历，得到左右根的后序遍历序列
	cout << endl;
}//后序遍历：左右根
```
核心思想：由前序遍历根左右演化而来，对前序遍历稍作变形，可以得到根右左的遍历顺序，在遍历的时候不打印，而是放入另一个栈中储存，这样再取另一个栈遍历，得到的就是左右根的后序遍历序列
## 后序遍历（单栈实现）
```
void postOrder2(node* root)
{
	node* temp = root;
	stack<node*> st;
	st.push(root);
	while (!st.empty())
	{
		node* top = st.top();
		if (temp != top->left && temp != top->right && top->left)
		{
			st.push(top->left);
		}//左子树未访问过，就把左子树的根放入栈
		else if (temp != top->right && top->right)
		{
			st.push(top->right);
		}//右子树未访问过，就把右子树的根放入栈
		else
		{
			cout << top->data << " ";
			temp = top;
			st.pop();
		}
		//要么左右子树都不存在，要么左右子树都已经访问过，那么就访问当前节点（根），
		//并且将temp指向当前节点，表示上一层树的左子树或右子树已经访问过
	}
	cout << endl;
}
```
核心思想：利用temp指针来判断当前节点的左右子树是否访问过