# 基本概念
本质上是一个节点最多可以链接两个节点，从而形成树状结构，而根节点和链表中的head指针一样，是该数据结构的标识，要想访问二叉树就得通过根节点 root
## 二叉搜索树
二叉搜索树要求左节点的值小于根节点小于右节点，以及左子树的所有值小于根节点小于右子树的所有值
## 二叉平衡树
要求任意节点左右子树的高度差不超过 
## 高度与深度
高度： 从当前节点到最远的叶子节点的边数，叶子节点高度为0，空节点高度为-1
深度： 从根节点到当前节点的边数
整棵树的高度就是根节点的高度
## 二叉树高度与节点数的关系

- **最坏情况（退化为链表）**：  
    高度 = n − 1 （所有节点一条线）。
    
- **最好情况（完全二叉树 / 满二叉树）**：  
    高度大约是 **log₂n**。
    
    - 满二叉树：结点数 n = 2^(h+1) − 1  
        ⇒ 高度 h ≈ log₂(n+1) − 1
        
    - 完全二叉树：高度差不多也是 ⌊log₂n⌋。
        

所以： log2​(n+1)−1≤h≤n−1
# 基本操作
## 插入
```
node* Getnode(int x)
{
	struct node* temp = new node();
	temp->data = x;
	temp->left = NULL;
	temp->right = NULL;
	return temp;
}
void Insert(node** root, int x)
{
	if (*root == NULL)
	{
		*root = Getnode(x);
	}
	else if (x <= (*root)->data)
	{
		Insert(&(*root)->left, x);
	}
	else
	{
		Insert(&(*root)->right, x);
	}
	return;
}
```
## 搜索
```
bool Search(node* root, int x)  // 改为传值，更简洁
{
	if (root == NULL)
	{
		return false;
	}
	else if (root->data == x)
	{
		return true;
	}
	else if (root->data < x)
	{
		return Search(root->right, x);
	}
	else
	{
		return Search(root->left, x);
	}
}
```
## 找最值
```
node* FindMin(node* root)
{
	if (root == NULL)
	{
		return root;
	}
	struct node* current = root;
	while (current->left != NULL)
	{
		current = current->left;
	}
     return current;
}
node* FindMax(node* root)
{
	if (root == NULL)
	{
		return root;
	}
	struct node* current = root;
	while (current->right != NULL)
	{
		current = current->right;
	}
	return current;
}
```
## 求高度
```
int Height(node* root)
{
	if (root == NULL)
	{
		return -1;
	}
	else
		return max(Height(root->left), Height(root->right)) + 1;
}
```
## 层级遍历
```
void LevelOrder(node* root)
{
	if (root == NULL)
	{
		return;
	}
	queue<node*> Q;
	Q.push(root);

	while (!Q.empty())
	{
		struct node* current = Q.front();
		if (current->left != NULL)
		{
			Q.push(current->left);
		}
		if (current->right != NULL)
		{
			Q.push(current->right);
		}
		cout << current->data << " ";
		Q.pop();
	}

}
```
## 前序遍历
```
void PreOrder(node* root)
{
	if (root == NULL)
	{
		return;
	}
	cout << root->data << " ";
	PreOrder(root->left);
	PreOrder(root->right);
}
```
## 中序遍历
```
void InOrder(node* root)
{
	if (root == NULL)
	{
		return;
	}
	InOrder(root->left);
	cout << root->data << " ";
	InOrder(root->right);
}
```
## 后序遍历
```
void PostOrder(node* root)
{
	if (root == NULL)
	{
		return;
	}
	PostOrder(root->left);
	PostOrder(root->right);
	cout << root->data << " ";
}
```
## 删除节点
```
node* deletenode(node* root, int x)
{
	if (root == NULL)
		return root;
	else if (x < root->data)
	{
		root->left = deletenode(root->left, x);
	}
	else if (x > root->data)
	{
		root->right = deletenode(root->right, x);
	}
	else
	{

		if (root->left == NULL && root->right == NULL)
		{
			delete root;
			root = NULL;
		}
		else if (root->left == NULL)
		{
			struct node* temp = root;
			root = root->right;
			delete temp;
		}
		else if (root->right == NULL)
		{
			struct node* temp = root;
			root = root->left;
			delete temp;
		}
		else
		{
			struct node* temp = FindMin(root->right);
			root->data = temp->data;
			root->right = deletenode(root->right, root->data);
		}
	}
	return root;
}
```
## 寻找中序后继节点
```
node* Getsuccessor(node* root, int data)
{
	struct node* current = Find(root, data);
	if (current == NULL)
		return NULL;
	struct node* ancestor = root;
	if (current->right != NULL)
	{
		return FindMin(current->right);
	}
	else
	{
		struct node* successor = NULL;
		while (ancestor && current != ancestor)
		{
			if (data < ancestor->data)
			{
				successor = ancestor;
				ancestor = ancestor->left;
			}
			else
			{
				ancestor = ancestor->right;
			}
		}
		return successor;
	}

}
```