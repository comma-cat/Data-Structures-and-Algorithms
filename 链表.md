# 基本结构
  链表不占用连续的内存空间，数据与数据之间通过指针来定位
  而与此对应的缺点就是，访问链表中元素的时间复杂度为O(n)，因为你只能从头节点开始一个一个地向下定位到你要寻找的元素
  链表由多个节点组成，而每个节点由两部分构成：数据与指针
  ```
  struct node()
  {
     int data;
     node *link;
  };
```
其中data便是存储的数据，而link（也叫next）就是指向下一个地址的指针
# 创建一个链表
```
struct node()
{
   int data;
   node *link;
};//定义节点
int main()
{
  node *head = NULL ;  //定义一个指向第一个节点的指针
  node *temp = new node () ; //创建一个node内存块，并定义一个指向该内存块的指针
  temp->data = 2 ; //对该节点的数据赋值
  head = temp ;  //将head指向该节点
  
}
```
这样就成功创建了一个只含一个节点的链表


```
struct node()
{
   int data;
   node *link;
};//定义节点
int main()
{
  node *head = NULL ;  //定义一个指向第一个节点的指针
  node *temp = new node () ; //创建一个node内存块，并定义一个指向该内存块的指针
  temp -> data = 2 ; //对该节点的数据赋值
  head = temp ;  //将head指向该节点
  temp = new node () ; //创建一个新的node内存块 , 并将temp指向该内存块
  temp -> data = 4 ;
  // 已经为第二个节点的数据赋值，只需要将第一个节点的link指向第二个节点即可
  node *temp1 = head ;
  while (temp1 -> link != NULL)
  {
     temp1 = temp1 -> link ;  // 目的是找到原链表的最后一个节点，该节点的link为NULL
  }
  temp1 -> = temp; //将原链表最后一个节点的link指向刚刚创建的新节点
  
}
```
至此就可以创建一个无限长的单链表
# 在任意位置添加一个节点
添加节点的基本逻辑：
   node： 1    2     3    4 .....
   假如要在位置n添加一个新的节点，只需要将n的next指向n-1处节点的next，再将n-1处节点的next指向位置n
   特殊情况：n=1,n-1处没有节点，只需要将新节点的next=head,再令head指向新节点即可
   ```
   void insert(int x,int position)
{
	struct node* temp1 = head;
	struct node* temp = new node();
	temp->data = x;
	if (position == 1)
	{
		temp->next = head;
		head = temp;
		return;
	} 
	for(int i = 0;i < position-2;i++)
	{
		temp1 = temp1->next;
	}   //令temp1指向第n-1个节点
	temp->next = temp1->next;
	temp1->next = temp;  //注意这两步的操作顺序，先更新新节点的next，再修改原节点的next
	return;
}
```
   
 假如n=1,链表为空呢？此时head = NULL,temp->data =x,而temp ->next =NULL,依然符合n = 1时的特殊情况，所以可以合并在一起
# 在任意位置删除一个节点
基本逻辑：
node: 1   2    3    4.....
在位置n处删除一个节点，就是要将n-1处节点的next变为n处节点的next，并且将第n处节点所占用的内存释放掉
特殊情况若n=1,则n-1处没有节点，这种情况也就是删除头节点，只需令head指向原链表第二个节点，再将第一个节点所占用内存释放即可
```
void deletenode(int position)
{
	struct node* temp1 = head;
	if (position == 1)
	{
		head = temp1->next;
		delete temp1;
		return;
	}
	for (int i = 0; i < position - 2; i++)
	{
		temp1 = temp1->next;
    }
	struct node *temp2 = temp1->next;
	temp1->next = temp2->next;
	delete temp2;
	return;
}
```
# 反转一个链表
## 使用循环迭代方式实现
基本逻辑：
三个指针变量：pre之前的节点   current现在的节点   next下一个节点
每次循环迭代，使现在节点的next指向前一个节点pre，完成一个箭头的变换
            
 ```
 void reverselist(struct node *pos)
{
	struct node *current = pos;
	
	while (current != NULL)
	{
		next = current->next;
		current->next = pre;
		pre = current;
		current = next;
		
	}
	head = pre;
}//循环方式反转链表
```
         
 注意赋值顺序，先更新next ,再更新指向，再更新pre，再更新current
 为什么next = current->next;不放在最后？
 问题在于：最后一次循环，current->next = null，执行完current = next之后，current = null,如果
 next = current->next放在最后面，就会出现null->next这种形式，显然是会报错，因此next放在首位更新
## 使用递归方式实现
```
void reverselist2(struct node *pos)
{
	struct node *temp = pos;
		if (temp->next == NULL)
		{
			head = temp;
            return;
        }  //递归的终止条件：达到链表的末端，并且将head指向末端
		
		reverselist2(temp->next);  //递归
		struct node *temp1 = temp->next;
		temp1->next = temp;
		temp->next = NULL;   //将下一个节点的next指向当前节点，并将当前节点的next赋为NULL
		return;
}
```

为了达到链表的终止条件，依次会递归reverselist2(头节点)->reverselist2(第二个节点)->...->reverselist2(最后一个节点)
而最后一个节点会结束递归，并返回空,又依次回到reverselist2(倒数第二个节点)->reverselist2(倒数第三个节点)->...->reverselist2(第一个节点)，并执行这三段代码：
struct node *temp1 = temp->next;
		temp1->next = temp;
		temp->next = NULL;

让temp->next = NULL的目的就是：当返回第一个节点时，能够让第一个节点指向NULL（否则以其他方式不好操作，不这样的话最后的结果是整个链表除了第一个节点完成了反转，但第一个节点仍然指向第二个节点，而第二个节点本身又指向第一个节点，导致无限循环的逻辑错误）。

# 双向链表
基本概念：
```
struct node
{
	int data;
	struct node* prev;
	struct node* next;
};
```
顾名思义，双向链表就是双向的链表，因此每个节点的link不仅有指向下一个节点的next,也有指向上一个节点的prev
基本操作：
在头部插入节点：
```
void Insertathead(int x)
{
	
	struct node* temp = Getanode(x);
	if (head == NULL)
	{
		head = temp;
		return;
	}
	temp->next = head;
	head->prev = temp;
	temp->prev = NULL;
	head = temp;
} //在头部插入一个节点
```
其中Getanode(x)可创建一个节点，其值为x，并且返回该节点的地址
注意:要单独考虑链表为空的情况，否则会出现NULL->next,NULL->prev，这样会导致报错
在尾部插入节点：
```
void Insertattail(int x)
{
	struct node* temp1 = head;
	struct node* temp2 = Getanode(x);
	if (temp1 == NULL)
	{
		head = temp2;
		return;
	} //单独处理链表为空的情况
	while (temp1->next != NULL)
	{
		temp1 = temp1->next;
	} //首先到达原链表最后一个节点
	temp1->next = temp2;
	temp2->prev = temp1;
	temp2->next = NULL;  //建立双向链接
} //在尾部插入一个节点
```
反向打印双向链表：
```
void Reverseprint(struct node* head)
{
	struct node* temp = head;
	if (temp == NULL)
	{
		cout << "该链表为空" << endl;
		return;
	}
	while (temp->next != NULL)
	{
		temp = temp->next;
	}  //到达最后一个节点
	while (temp != NULL)
	{
		cout << temp->data << " ";
		temp = temp->prev;
	}  //反向遍历
	cout << endl;
}
```
利用双向链表“双向的特性”，先到达最后一个节点，利用prev指针，向前遍历并打印