# 什么是前缀树
前缀树（Trie，又叫字典树）是一种**树形结构**，用来高效处理：

- 单词数量统计
    
- 前缀查询
    
- 自动补全
    
- 字符串查找
    
- 字典序遍历
    
- 多字符串匹配（AC 自动机的基础）

核心思想：**把字符串按照字符顺序一个一个挂在树结构里，共享前缀路径**
例如在前缀树中放入apple 与 app, app作为共同前缀，只存了一次
# 前缀树的作用
-  插入string
- 查询某string被放入了几次
- 查询以string为前缀的次数
- 在树中删除string
# 前缀树的优势
因为 Trie 不依赖 string 的数量，而依赖 string 的长度。

例如：

有 10 万个单词，每个长度为 10  
查询一个单词需要多少时间？

时间 = 10 步  
**与单词数量完全无关！**

这比 hash / set / map 快在：

- 不需要比较整个字符串
    
- 不需要计算 hash
    
- 不需要重新哈希或链表查找
    
- 前缀操作天然支持
    

因此 Trie 特别适合大规模字符串处理。

# 前缀树的代码实现

## 用类实现前缀树
### 原理
前缀树到底是怎么来表达一个字符串的呢？
在动态实现的情况下，是通过next数组的指针来表达的
在静态实现的情况下，是通过tree二维数组来表达的
例如插入"abc"，那么abc在前缀树中如何表达呢？
a对应0,那么a是否在前缀树的第一层出现就取决于第一层节点的next[0]是否为nullptr
如果为空，说明a不存在，则需要创建需要让 next[0]指向一个新节点，这样之后next[0]不为空，a就存在了
同理b，首先要经过a，到达第二层节点，b是否存在就取决于第二层节点的next[1]是否为nullptr了
所以说一个字符是否存在：
1. 字符在字符串的位置确定在哪一个节点
2. 字符的值确定该节点next数组的下标值 path = char - 'a';
3. 通过该next数组的特定下标值是否为空来判断该字符是否存在
### 节点的结构
前缀树是一种树形结构，所以需要节点作为基本机构
一个节点里面首先需要有一个 pass值表示“经过”的次数，end值表示在这里“结尾”的次数
同时还需要一个next数组来表示这个节点在哪些方向上有路，哪些方向上没有路
```
class Node
{
public:
	int pass;
	int end;
	vector<Node*> next;
	Node() : pass(0), end(0), next(26, nullptr) {}
	
};
```

而前缀树作为树形结构，必然有一个root为树的起点，因此在前缀树的类里面需要一个Node类型的root变量表示树根
### 插入操作
给定一个字符串，将其放入前缀树中，在放入过程中，所有经过的节点pass值++，结尾处end值++，如果该前缀树中本身已经有了字符，则直接跳转，反之则先创建节点再进行跳转
```
void insert(string word)
{
	Node* node = root;
	node->pass++; 
	for (int i = 0; i < word.size(); i++)
	{
		
		int path = word[i] - 'a';
		if (node->next[path] == nullptr)
		{
			node->next[path] = new Node();
		}//如果之前没有经过这条边，则创建
		node = node->next[path];
		//node跳转到下一个node
		node->pass++;
	}
	node->end++;//循环结束后再令end++
}
```
### countWord操作
```
int countWord(string word)
{
	Node* node = root;
	for (int i = 0; i < word.size(); i++)
	{
		int path = word[i] - 'a';
		if (node->next[path] == nullptr)
		{
		return 0;//如果某个位置指针为空，说明该字符不存在，进而该字符串也就不存在，直接返回空
		}
		node = node->next[path];
	}
	return node->end;//如果能成功到达最后，则返回end值即代表该word放入的次数
}
```
### countPrefix操作
```
int countPrefix(string word)
{
	Node* node = root;
	for (int i = 0; i < word.size(); i++)
	{
		int path = word[i] - 'a';
		if (node->next[path] == nullptr)
			return 0;
		node = node->next[path];
    	}
	return node->pass;//与countWord唯一的区别就是结束时返回的是pass值表达“经过”的次数
}
```
### 删除操作
```
void deleteWord(string word)
{
	if (countWord(word) == 0) return;
	//该word必须在树中才能删除，否则直接返回
	Node* node = root;
	node->pass--;
	for (int i = 0; i < word.size(); i++)
	{
		int path = word[i] - 'a';
		if (--node->next[path]->pass == 0)
		{
			deleteNode(node->next[path]);
			node->next[path] = nullptr;
			return; //这里需要释放内存，需要优化，否则会内存泄漏
		}
		//如果下一个节点的pass为空，说明该分支都可以放弃，所以node->next[path] = nullptr;
		//但是当时创建的节点还在，在C++中必须手动删除，否则会造成内存泄漏
		//所以必须deleteNode(node->next[path]);
		node = node->next[path];
	}
	node->end--;
}
```
 ```
 void deleteNode(Node* node)
{
	if (node == nullptr) return;

	for (int i = 0; i < 26; i++)
	{
		if (node->next[i] != nullptr)
		{
			deleteNode(node->next[i]);
		}
	}
	delete node;
}
//deleteNode函数采用递归的方式删除节点，从而避免内存泄漏
 ```
### 用类实现前缀树的代码
```
#include<iostream>
#include<vector>
using namespace std;

class trie
{ 
	class Node
	{
	public:
		int pass;
		int end;
		vector<Node*> next;
		Node() : pass(0), end(0), next(26, nullptr) {}
		
	};
	Node* root;

public:
	void deleteNode(Node* node)
	{
		if (node == nullptr) return;

		for (int i = 0; i < 26; i++)
		{
			if (node->next[i] != nullptr)
			{
				deleteNode(node->next[i]);
			}
		}
		delete node;
	}
	trie()
	{
		root = new Node();
	}
	~trie()
	{
		deleteNode(root);
	}
	//注意，由于类内申请了新的空间，因此析构函数是必须的，否则会导致内存泄漏
	void insert(string word)
	{
		Node* node = root;
		node->pass++; 
		for (int i = 0; i < word.size(); i++)
		{
			
			int path = word[i] - 'a';
			if (node->next[path] == nullptr)
			{
				node->next[path] = new Node();
			}//如果之前没有经过这条边，则创建
			node = node->next[path];
			//node跳转到下一个node
			node->pass++;
		}
		node->end++;//循环结束后再令end++
	}
	int countWord(string word)
	{
		Node* node = root;
		for (int i = 0; i < word.size(); i++)
		{
			int path = word[i] - 'a';
			if (node->next[path] == nullptr)
			{
				return 0;
			}
			node = node->next[path];
		}
		return node->end;
	}
	void deleteWord(string word)
	{
		if (countWord(word) == 0) return;
		Node* node = root;
		node->pass--;
		for (int i = 0; i < word.size(); i++)
		{
			int path = word[i] - 'a';
			if (--node->next[path]->pass == 0)
			{
				deleteNode(node->next[path]);
				node->next[path] = nullptr;
				return; //这里需要释放内存，否则会内存泄漏
			}
			node = node->next[path];
		}
		node->end--;
	}
	int countPrefix(string word)
	{
		Node* node = root;
		for (int i = 0; i < word.size(); i++)
		{
			int path = word[i] - 'a';
			if (node->next[path] == nullptr)
				return 0;
			node = node->next[path];
     	}
		return node->pass;
	}
};

int main()
{
	trie A;
	A.insert("abcd");
	A.insert("abc");
	cout << A.countPrefix("ab") << endl;//2
	cout << A.countWord("abc") << endl;//1
	A.deleteWord("abc");
	cout << A.countPrefix("a") << endl;//1
	return 0;
}
```
### 利用哈希表代替next数组
如果说需要表示的字符数不只是26中，而是65536种甚至更多，那么使用next数组就会耗费大量空间，这个时候就可以利用哈希表建立字符与 Node* 之间的对应来代替next数组即可，代码如下:
```
#include<iostream>
#include<vector>
#include<unordered_map>
using namespace std;
class trie
{public:
	class Node
	{
	public:
		int pass;
		int end;
		unordered_map<char,Node*> mp;
		Node() :pass(0), end(0) {}

	};
	Node* root;
	trie()
	{
		root = new Node();
	}
	~trie()
	{
		deleteNode(root);
	}
	void insert(string word)
	{
		Node* node = root;
		node->pass++;
		for (int i = 0; i < word.size(); i++)
		{
			char index = word[i];
			if (node->mp.find(index) == node->mp.end())
			{
				node->mp[index] = new Node();
			}
			node = node->mp[index];
			node->pass++;
		}
		node->end++;
	}
	int countWord(string word)
	{
		Node* node = root;
		for (int i = 0; i < word.size(); i++)
		{
			char index = word[i];
			if (node->mp.find(index) == node->mp.end())
			{
				return 0;
			}
			node = node->mp[index];
		}
		return node->end;
	}
	int countPrefix(string word)
	{
		Node* node = root;
		for (int i = 0; i < word.size(); i++)
		{
			char index = word[i];
			if (node->mp.find(index) == node->mp.end())
			{
				return 0;
			}
			node = node->mp[index];
		}
		return node->pass;
	}
	void deleteNode(Node* node)
	{
		if (node == NULL) return;
		for (auto i : node->mp)
		{
			deleteNode(i.second);
		}
		delete node;
	}
	void deleteWord(string word)
	{
		if (countWord(word) == 0) return;
		Node* node = root;
		node->pass--;
		for (int i = 0; i < word.size(); i++)
		{
			char index = word[i];
			if (--node->mp[index]->pass == 0)
			{
				deleteNode(node->mp[index]);
				node->mp.erase(index);
				return;
	
			}
			node = node->mp[index];
			
		}
		node->end--;
	}
};
int main()
{
	trie A;
	A.insert("abcd");
	A.insert("abc");
	cout << A.countPrefix("ab") << endl;//2
	cout << A.countWord("abc") << endl;//1
	A.deleteWord("abc");
	cout << A.countPrefix("a") << endl;//1
	return 0;
}
```
## 用静态数组的方式实现前缀树
### 原理
提前申请空间，需要一个tree二维数组，一个pass数组，一个trieEnd数组,一个cnt全局变量
`tree[x][y]`表示第x个节点的y路径是否存在，如果值为0，说明路径不存在，如果值为k，则说明路径存在，并且下一个节点是k节点
相当于我们用tree这个二维数组将next数组替换掉了
如果路径不存在，则我们创建路径`tree[x][y] = ++cnt` ,用cnt来记录节点数，保证新创建节点时不会重复（实际上这里没有创建，所有的空间在申请静态数组时就已经存在了）
### 代码
```
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXN = 10000;
int tree[MAXN][26];
int pass[MAXN];
int trieEnd[MAXN];
int cnt;
void build()
{
	cnt = 1;
}
//创建操作只需要给cnt赋初值1即可，这说明1就是该实现方式下前缀树的树根
// 将 end 数组重命名为 trieEnd，避免与 std::end 冲突
// 修改 insert 函数中的 end[cur]++ 为 trieEnd[cur]++
void insert(string word)
{
	int cur = 1;
	pass[cur]++;
	for (int i = 0; i < word.size(); i++)
	{
		int path = word[i] - 'a';
		if (tree[cur][path] == 0)
		{
			tree[cur][path] = ++cnt;
		}
		//为0代表路径不存在，则给“指定”一个路径，让当前节点指向++cnt
		cur = tree[cur][path];
		pass[cur]++;
	}
	trieEnd[cur]++;
}
int countWord(string word)
{
	int cur = 1;
	for (int i = 0; i < word.size(); i++)
	{
		int path = word[i] - 'a';
		if (tree[cur][path] == 0)
		{
			return 0;
		}
		cur = tree[cur][path];
	}
	return trieEnd[cur];
}
int countPrefix(string word)
{
	int cur = 1;
	for (int i = 0; i < word.size(); i++)
	{
		int path = word[i] - 'a';
		if (tree[cur][path] == 0)
		{
			return 0;
		}
		cur = tree[cur][path];
	}
	return pass[cur];
}
// 将 delete 函数重命名为 deleteWord，避免与 C++ 关键字冲突
void deleteWord(string word)
{
	if (countWord(word) == 0) return;
	int cur = 1;
	pass[cur]--;
	for (int i = 0; i < word.size(); i++)
	{
		int path = word[i] - 'a';
		if (--pass[tree[cur][path]] == 0)
		{
			tree[cur][path] = 0;
			return;
		}
		//注意这里：如果下一个节点的pass为0，说明该分支可以放弃了，在静态方式实现种
		//只需调整二维数组tree的指向，无需去删除，这是因为该分支的这些节点在以后永远也不会用了
		//因此无需删掉该分支的脏数据（这也是为什么“创建”节点时是指向++cnt）
		//这些分支的节点只可能在下一轮才有可能再次使用，而到下一轮之前我们本身也要进行clear操作
		cur = tree[cur][path];
	}
	trieEnd[cur]--;
}
void clear()
{
	for (int i = 1; i <= cnt; i++)
	{
		fill(tree[i],tree[i] + 26, 0);
		pass[i] = 0;
		trieEnd[i] = 0;
	}
	cnt = 1;
	//清空脏数据，下一轮构建前缀树时空间可复用
}
int main()
{
	build();
	insert("hello");
	insert("hel");
	cout << countWord("hello") << endl;
	cout << countPrefix("he") << endl;
	deleteWord("hello");
	cout << countPrefix("he") << endl;
	clear();

}
}
```
## 三种实现方式的对比
# 1. **动态 Trie（next[26] 数组）**

特点：

- 每个节点用 `new` 分配
    
- `next[26]` 是固定数组
    
- 最常见的教学版本、OJ 版本
    

优点：

- 实现简单
    
- 内存按需增长
    
- 字符访问速度快（O(1)）
    
- 节点结构紧凑
    

缺点：

- new node 会导致内存碎片
    
- 节点不连续 → 缓存友好性较差
    
- 仅适合固定字符集（如 26 小写字母）
    

---

# 2. **动态 Trie（map/unordered_map）**

特点：

- 每个节点是一个 map（或 unordered_map）
    
- 不限制字符集（可几百、几千字符）
    

优点：

- 字符集任意扩展
    
- 节点中只存实际存在的边（节省稀疏字符集空间）
    

缺点：

- map 查询 O(log n)，unordered_map 查询 O(1)*（但重哈希、冲突会拖慢）
    
- 哈希表内部结构复杂，占内存多
    
- CPU 缓存不友好
    
- 最慢的 Trie 实现
    

适合：

- URL 前缀
    
- Unicode 字符
    
- 不规则字典树
    

---

# 3. **静态 Trie（二维数组）**

特点：

- `tree[MAXN][26]`
    
- 所有节点在数组中连续
    
- 使用 `cnt` 来管理节点索引
    

优点：

- 访问速度最快
    
- 所有节点连续 → CPU cache 极度友好
    
- 无 new，无碎片
    
- 内存固定，开销可控
    
- 最适合大规模数据、竞赛、笔试
    

缺点：

- 需要提前估计最大节点数
    
- 空间“不按需”，可能浪费
    
- 仍限于固定字符集
