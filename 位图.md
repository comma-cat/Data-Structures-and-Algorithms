# 什么是位图？
位图是用来存储一串**连续整数数字**的方式，一般情况下存储一个整数需要分配四个字节，32bit的空间，但是位图中，**用一个bit的状态(1或0)来表示一个数字是否存在**，从而大大压缩了存储整数的空间，在位图中只需要一个bit就可以存储一个整数
# 位图的大小
我们使用一个整形数组set来实现位图，那么这个set数组应该指派多大的大小呢？
```
vector<int> bitSet(int n)
{
	int size = (n + 31) / 32;
	vector<int> set(size, 0);
	return set;
}
```
很简单的例子，假如我要存储从0-n-1范围一共n个数
set中每多一个整形数据，就可以多存32个数
那么总共需要的set中整形数据的数量为 (n+31)/32(相当于n/32再向上取整)
# 位图的基本操作
## 加入数据
```
void addNum(int n, vector<int>& set)
{
	int index = n / 32;
	int bit = n % 32;
	set[index] |= 1 << bit;
}
```
由于一个整型数据存储32个数字，那么我加入一个整数，这个整数应该在set数组中的哪个位置呢？
` int index = n / 32;`
加入的这个整数用set中这个位置的数据的哪个一个bit位来表示呢？
` int bit = n % 32`
现在将`set[indext]`的第bit位调整为1
`set[index] |= 1 << bit;
## 删除数据
```
void removeNum(int n, vector<int>& set)
{
	int index = n / 32;
	int bit = n % 32;
	set[index] &= ~(1 << bit);
}
```
通过index和bit确定这个数存储set数组中哪一个位置的哪一位bit上
现在将这一位上的数字变为0
`set[index] &= ~(1 << bit);`
这里~(1 << bit) 即表示 `...11111011111...`0位置就对应存储数据的那一位bit，取与运算，就可以让0之外的位置保持原样，在0位置的状态变为0
--**为什么这里不直接异或1<<bit呢？**
    使用异或，如果0位置的数据本身就是0,异或上1 << bit,该位置就会变成1，也就是说我们本来是要删除这个数，但是当这个数本来就没存在里面的时候，我们反而把他存进去了，实际上执行的是一个reverse的操作，而不是remove
## 反转状态
```
void flip(int n, vector<int>& set)
{
	int index = n / 32;
	int bit = n % 32;
	set[index] ^= 1 << bit;
}
```
这里使用异或，就可以实现：
如果没存这个数，存进去
如果存了这个数，删掉
这也是为什么在removeNum中不用异或的原因
## 判断某个数是否存储
```
bool contain(const vector<int>& set, int n)
{
	int index = n / 32;
	int bit = n % 32;
	return !((set[index] & (1 << bit)) == 0);
}
```
判断一个数是否存了，首先得找到这个数是哪个位置的哪一个bit表示的，然后判断这个bit是0还是1即可
`set[index] & (1 << bit) == 0` 如果这个成立，说明目标位为0，未存储，应该return false
                            如果这个不成立，说明目标位为1，已存储,应该return true
所以直接`return !((set[index] & (1 << bit)) == 0);`即可
# 利用对数器验证位图
# 得到随机数
```
int getRandomInt(int a, int b) {
	static random_device rd;
	static mt19937 gen(rd());
	uniform_int_distribution<> dist(a, b);
	return dist(gen);
}
double getRandomDouble(double a, double b) {
	static random_device rd;
	static mt19937 gen(rd());
	uniform_real_distribution<> dist(a, b);
	return dist(gen);
}
```

| 层级       | 类名 / 概念                          | 作用                |
| -------- | -------------------------------- | ----------------- |
| ① 随机种子来源 | `std::random_device`             | 提供初始随机性（真实或伪随机）   |
| ② 随机数引擎  | `std::mt19937`                   | 生成大批伪随机数（速度快、质量高） |
| ③ 分布模型   | `std::uniform_int_distribution`  | 把整数随机数映射成想要的分布区间  |
| ③ 分布模型   | `std::uniform_real_distribution` | 把浮点数随机数映射成想要的分布区间 |
# 构造unoredered_set进行对数器验证
```
int testtimes = 10000;
cout << "测试次数为: " << testtimes << endl;
unordered_set<int>st;
int n = 50000;
cout << "数字范围为：" << "0 - " << n << endl;
vector<int>set = bitSet(n);
cout << "测试开始" << endl;
while (testtimes--)
{
	double random_num = getRandomDouble(0.0, 1.0);
	int num = getRandomInt(0, 50000);
	if (random_num < 0.33)//放入
	{
		st.insert(num);
		addNum(num, set);
	}
	else if (random_num < 0.66)//删除
	{
		st.erase(num);
		removeNum(num, set);
	}
	else//反转
	{
		flip(num, set);
		if (st.count(num))
		{
			st.erase(num);
		}
		else
		{
			st.insert(num);
		}
	}
	
}
for (int i = 0; i < n; i++)
{
	if (contain(set, i) != st.count(i))
	{
		cout << "出现不匹配，程序有错" << endl;
	}
}
cout << "数据吻合，程序正确" << endl;
cout << "测试结束" << endl;

```
最后附上整个位图的构建以及对数期验证的代码：
```
#include<iostream>
#include<vector>
#include<unordered_set>
#include<random>
using namespace std;
static random_device rd;
static mt19937 gen(rd());
vector<int> bitSet(int n)
{
	int size = (n + 31) / 32;
	vector<int> set(size, 0);
	return set;
    
}
void addNum(int n, vector<int>& set)
{
	int index = n / 32;
	int bit = n % 32;
	set[index] |= 1 << bit;
}
void removeNum(int n, vector<int>& set)
{
	int index = n / 32;
	int bit = n % 32;
	set[index] &= ~(1 << bit);
}
void flip(int n, vector<int>& set)
{
	int index = n / 32;
	int bit = n % 32;
	set[index] ^= 1 << bit;
}
bool contain(const vector<int>& set, int n)
{
	int index = n / 32;
	int bit = n % 32;
	return !((set[index] & (1 << bit)) == 0);
}
int getRandomInt(int a, int b) {
    uniform_int_distribution<> dist(a, b);
	return dist(gen);
}
double getRandomDouble(double a, double b) {
	
	uniform_real_distribution<> dist(a, b);
	return dist(gen);
}
int main()
{
	int testtimes = 10000;
	cout << "测试次数为: " << testtimes << endl;
	unordered_set<int>st;
	int n = 50000;
	cout << "数字范围为：" << "0 - " << n << endl;
	vector<int>set = bitSet(n);
	cout << "测试开始" << endl;
	while (testtimes--)
	{
		double random_num = getRandomDouble(0.0, 1.0);
		int num = getRandomInt(0, 50000);
		if (random_num < 0.33)//放入
		{
			st.insert(num);
			addNum(num, set);
		}
		else if (random_num < 0.66)//删除
		{
			st.erase(num);
			removeNum(num, set);
		}
		else//反转
		{
			flip(num, set);
			if (st.count(num))
			{
				st.erase(num);
			}
			else
			{
				st.insert(num);
			}
		}
		
	}
	for (int i = 0; i < n; i++)
	{
		if (contain(set, i) != st.count(i))
		{
			cout << "出现不匹配，程序有错" << endl;
		}
	}
	cout << "数据吻合，程序正确" << endl;
	cout << "测试结束" << endl;

}
```