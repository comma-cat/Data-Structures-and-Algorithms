# Kruskal算法
## 代码部分
```
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
int MAX = 10000;
int fa[10000];
void build(int n)
{
	for (int i = 1; i <= n; i++)
	{
		fa[i] = i;
	}
}
int find(int x)
{
	if (x != fa[x])
	{
		fa[x] = find(fa[x]);
	}
	return fa[x];
}
bool unionSet(int x, int y)
{
	int fx = find(x);
	int fy = find(y);
	if (fx == fy)
	{
		return false;
	}
	fa[fy] = fx;
	return true;

}
struct cmp {
	bool operator()(const vector<int>& a, const vector<int>& b) const {
		return a[2] > b[2]; // 小顶堆
	}
};



int main()
{
	int n = 5, m = 9;
	build(n);
	//n，m分别为点和边的数量
	vector<vector<int>> road{ {1,2,1},{1,5,3},{1,3,7},{2,5,5},{2,4,1},{3,4,9},{4,2,2},{5,3,9},{5,4,6} };
	//这里省略建图过程，直接给出图
	priority_queue<vector<int>, vector<vector<int>>, cmp> pq;
    // 修正优先队列的声明，使用自定义比较器结构体
   
	for (auto i : road)
	{
		pq.push(i);
	}
	int ans = 0;
	int ct = 0;
	while (!pq.empty())
	{
		if (unionSet(pq.top()[0], pq.top()[1]))
		{
			ans += pq.top()[2];
			ct++;	
		}
		pq.pop();
	}
	ans = ct == n - 1 ? ans : -1;
	//kruscal算法的核心代码
	cout << ans << endl;
	
	
}
/*
         1     →（1）         2  
           ↘（3） （5）↙
	（7）↓       5      （1）↓↑（2）
          （9）↙   ↘（6）
        3     →（9）          4
*/
```