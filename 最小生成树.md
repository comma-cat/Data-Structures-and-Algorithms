# 最小生成树
什么是最小生成树？
最小生成树就是在一个 **无向带权图中** 能将所有点联通的边和点所构成的权值和最小的图结构
要点：
- 要将所有点都联通，边数 = 点的个数 - 1
- 要求边的权值和最小
# Kruskal算法
## 原理

我们将所有的边，按照权值进行升序排列
然后遍历这个边集：
如果边的起点和终点 目前没有在同一个集合（使用并查集实现）中， 说明 不会形成环
并且取出的当前边是权值最小的， 因此就可以取这一条边，再进行下一次遍历
如果边的起点和终点 目前已经在同一个集合中， 说明 会形成闭环
我们就不能取当前边，继续向下遍历

当遍历完之后，最终边数应该为点数减1，最终的权值就是该过程取的边的权值之和
如果边数不为点数减1，说明给定的图可能本来就不连通，也就不存在最小生成树

## 代码部分
```
#include<iostream>
#include<vector>
#include<queue>
#include<algorithm>
using namespace std;
int MAX = 10000;
int fa[10000];
void build(int n)
{
	for (int i = 1; i <= n; i++)
	{
		fa[i] = i;
	}
}
int find(int x)
{
	if (x != fa[x])
	{
		fa[x] = find(fa[x]);
	}
	return fa[x];
}
bool unionSet(int x, int y)
{
	int fx = find(x);
	int fy = find(y);
	if (fx == fy)
	{
		return false;
	}
	fa[fy] = fx;
	return true;
}
//以上都是并查集的相关操作，注意不同点：unionSet返回值为bool类型，利于后续处理
int main()
{
	int n = 5, m = 9;
	build(n);
	//n，m分别为点和边的数量
	vector<vector<int>> edges{ {1,2,1},{1,5,3},{1,3,7},{2,5,5},{2,4,1},{3,4,9},{4,2,2},{5,3,9},{5,4,6} };
	//注意：Kruskal算法是不需要建图的，也不需要用堆，只需要一个**按权重升序**的边集即可
	sort(edges.begin(), edges.end(), [](const auto& a, const auto& b) {
		return a[2] < b[2];
		}); //使用lambda表达式实现按权重的升序排列
	int ans = 0;
	int ct = 0;
	for (auto i : edges)
	{
		if (unionSet(i[0], i[1]))
		{
			ans += i[2];
			ct++;
		}
	}
	//核心逻辑：遍历边集，如果起点终点不在同一集合，则取该边，反之则跳过该边
	ans = ct == n - 1 ? ans : -1;
	//只有当边数 = 点数 - 1才说明最小生成树是构建成功的,否则返回-1说明无法构建最小生成树
	cout << ans << endl;


}
/*
		 1     →（1）         2
		   ↘（3） （5）↙
	（7）↓       5      （1）↓↑（2）
		  （9）↙   ↘（6）
		3     →（9）          4
*/
```
## 时间复杂度分析
点的个数为n,边的个数为m
建立并查集:O(n)
遍历边集合：O（m）
对边集排序：O（m * log m）
所以时间复杂度是：O(m * log m) + O(m) + O(n)

# Prim算法
# 原理
Prim算法，首先需要建立无向图
```
  vector<vector<pair<int, int>>> graph(n + 1);
  for (size_t i = 0; i < edges.size(); i++) {
      int u = edges[i][0], v = edges[i][1], w = edges[i][2];
      graph[u].push_back(make_pair(v, w));
      graph[v].push_back(make_pair(u, w));
  }
```
然后，我们从任意一个点开始，把该点加入set集合，并且将由该点出发的所有边，都加入一个按权重比较的小根堆
 ```
   priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    vector<bool> st(n + 1, false);

    st[1] = true;
    for (size_t i = 0; i < graph[1].size(); i++) {
        int v = graph[1][i].first;
        int w = graph[1][i].second;
        pq.push({ w, v });
    }//注意这里是用greater<>实现小根堆，为了按权值排序，因此将w放在v前面，加入堆中
 ```
核心部分：
从小根堆中取出元素（是一个pair类型）
如果该点没有在set集合中，说明不会形成闭环，可以取该边
如果该点已经在set集合中，说明会形成环，不能取该边，直接pop掉，判断下一个堆顶

当成功从堆中取到一条边之后，将该边的终点加入set集合，来表明该点已经被连接在同一个集合中，同时再将由该点出发的所有边加入小根堆，重复以上操作

这样一直操作到小根堆为空，即可得到最小生成树
```
 while (!pq.empty() && cnt < n - 1) {
     pair<int, int> top = pq.top();
     pq.pop();
     int w = top.first;
     int u = top.second;
     if (st[u]) continue; //如果已经在集合中，则跳过

     st[u] = true;
     ans += w;
     cnt++;
     //否则就取该边，将终点加入set集合中

     for (size_t i = 0; i < graph[u].size(); i++) {
         int v = graph[u][i].first;
         int wt = graph[u][i].second;
         if (!st[v]) pq.push({ wt, v });
     }//并且将由该点出发的所有边也加入小根堆中
 }
```
# 代码部分
```
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int main() {
    vector<vector<int>> edges{
        {1, 2, 1}, {1, 5, 3}, {1, 3, 7},
        {2, 5, 5}, {2, 4, 1}, {3, 4, 9},
        {4, 2, 2}, {5, 3, 9}, {5, 4, 6}
    };
    int n = 5;

    // 建无向图
    vector<vector<pair<int, int>>> graph(n + 1);
    for (size_t i = 0; i < edges.size(); i++) {
        int u = edges[i][0], v = edges[i][1], w = edges[i][2];
        graph[u].push_back(make_pair(v, w));
        graph[v].push_back(make_pair(u, w));
    }

    // 最小堆：{边权, 节点}
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    vector<bool> st(n + 1, false);

    st[1] = true;
    for (size_t i = 0; i < graph[1].size(); i++) {
        int v = graph[1][i].first;
        int w = graph[1][i].second;
        pq.push({ w, v });
    }

    int ans = 0, cnt = 0;

    while (!pq.empty() && cnt < n - 1) {
        pair<int, int> top = pq.top();
        pq.pop();
        int w = top.first;
        int u = top.second;
        if (st[u]) continue;

        st[u] = true;
        ans += w;
        cnt++;

        for (size_t i = 0; i < graph[u].size(); i++) {
            int v = graph[u][i].first;
            int wt = graph[u][i].second;
            if (!st[v]) pq.push({ wt, v });
        }
    }

    if (cnt != n - 1) ans = -1;
    cout << ans << endl;

    return 0;
}
```
## 时间复杂度分析
建图的过程：O（n+m）
建堆和出堆的过程：O(m * log m)
（总共2m条边进入，2m条边弹出,而小根堆会自动排序）

